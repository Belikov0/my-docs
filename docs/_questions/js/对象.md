# 对象

## 判断一个对象是否有某一个键

**方法一**：使用`[]`取值

缺点：不能找到值为`undefined`的键

```js
function hasKey(obj, key) {
    return obj[key] === undefined
}
```

**方法二**：使用迭代方法`Object.keys()`

缺点：不能找到使用`defineProperty`设置了属性`enumerable:false`的键

```js
function hasKey(obj, key) {
    return Object.keys(obj).includes(key)
}
```

**方法三**：`hasOwnProperty()`方法

缺点：不能找到原型链上的属性

```js
function hasKey(obj, key) {
    return obj.hasOwnProperty(key)
}
```

**方法四**：`in`运算符

```js
function hasKey(obj, key) {
    return key in obj
}
```

## 判断空对象

判断空对象有两种情况：

-   对象本身为空对象，不关心原型是否存在属性
-   对象本身和原型上都没有属性

在这里我们讨论第一种情况。

**方法一**：对象的属性是可以迭代的

由于`for in`运算能够遍历到原型上的属性，故还需要使用`hasOwnProperty`进行判断

```js
function isEmptyObject(obj) {
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            return false
        }
    }
    return true
}
```

**方法二**：`Object.keys()`方法

由于`Object.keys()`方法只能获取到对象自身的属性而不能获取到原型的属性，
故只能用于判断对象自自身为空。

```js
function isEmptyObject(obj) {
    return Object.keys(obj || []).length === 0
}
```

**方法三**：`JSON`方法

该方法在对象中有函数时失效

```js
function isEmptyObject(obj) {
    return JSON.stringift(obj) === "{}"
}
```

## 判断两个值相等

**方法一**：使用ES6方法[`Object.is()`](/docs/frontend/js/basic/Object.md#object-is)判断相等

```js
function isEqual(valA, valB) {
    return Object.is(valA, valB)
}
```

**方法二**：使用运算符判断边界情况（`Vue`实现）

这种方法能够正确处理传入的参数为`NaN`的情况

```js
function isNotEqual(valA, valB) {
    return valA !== valB && (valA === valA || valB === valB)
}

function isEqual(valA, valB) {
    return !isNotEqual(valA, valB)
}
```

判断多个值是否相等时，可以采用递归的思想

```js
function isMultiEqual(val, ...rest) {
    return isEqual(val, rest[0]) && (rest.length < 2 || isMultiEqual(...rest))
}
```

## new一个对象时发生了什么

使用`new`操作符调用构造函数时会执行如下操作

-   在内存中创建一个对象
-   这个新对象的[[Prototype]]特性被赋值为构造函数的`prototype`属性
-   构造函数内部的`this`被赋值为这个新对象，即`this`指向新对象
-   执行构造函数内的代码
-   如果构造函数返回非空对象，返回该对象，否则返回刚新创建的对象

```js
function Person() {
    this.name = "Jack"
    this.sayHi = function () {
        console.log(`Hi, I am ${this.name}`)
    }
}

// 执行new Person
const person = (function () {
    const person = {}
    person.prototype = Person.prototype
    Person.this = person // 伪代码
    Person()
    return person
})()
```
